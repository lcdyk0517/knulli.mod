name: Batocera Mod → Release → Baidu Netdisk

on:
  workflow_dispatch:
    inputs:
      image_url:
        description: "待魔改镜像直链（支持 .img 或 .img.gz）"
        required: true
        type: string
      release_tag:
        description: "Release tag（留空则自动生成）"
        required: false
        type: string
      prerelease:
        description: "是否标记为 Pre-release"
        required: false
        default: false
        type: boolean
      baidu_path:
        description: "百度网盘上传目录（默认：/knulli_mod/）"
        required: false
        type: string

permissions:
  contents: write   # 创建/更新 Release 需要

jobs:
  build-and-release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          # losetup/mount/umount 通常自带；这里安装其他依赖
          sudo apt-get install -y squashfs-tools unzip xz-utils curl coreutils gzip file

      - name: Download image
        id: dl
        run: |
          set -euxo pipefail
          URL="${{ inputs.image_url }}"
          echo "Downloading: $URL"
          curl -L --fail -o input.img.any "$URL"
          if [[ "$URL" =~ \.gz($|\?) ]] || file input.img.any | grep -qi "gzip compressed data"; then
            echo "Detected gzip archive, decompressing..."
            gunzip -c input.img.any > image.img
          else
            mv input.img.any image.img
          fi
          ls -lh image.img
          echo "image_path=image.img" >> "$GITHUB_OUTPUT"

      - name: Make mod script executable
        run: chmod +x ./mod_knulli_from_img.sh

      - name: Run mod script
        # 你的脚本里已内置默认 MOD_URL（GitHub Release 的 mod_files.zip）
        run: sudo ./mod_knulli_from_img.sh "${{ steps.dl.outputs.image_path }}"

      - name: Generate checksums
        run: sha256sum image.img | tee image.img.sha256

      - name: Check file size
        id: sizecheck
        run: |
          BYTES=$(stat -c%s image.img)
          echo "File size: $BYTES"
          THRESH=$((2*1024*1024*1024))
          if [ "$BYTES" -gt "$THRESH" ]; then
            echo "need_split=true" >> "$GITHUB_OUTPUT"
          else
            echo "need_split=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Split into 2GiB parts (if needed)
        if: steps.sizecheck.outputs.need_split == 'true'
        run: |
          # 以 2000MiB 切分，留出余量；生成分卷校验
          split -b 2000m -d -a 2 image.img image.img.part.
          for f in image.img.part.*; do
            sha256sum "$f" >> image.img.parts.sha256
          done
          ls -lh image.img.part.* image.img.parts.sha256

      - name: Prepare release tag
        id: tag
        run: |
          DATE=$(date -u +%Y%m%d-%H%M%S)
          AUTO_TAG="knulli-mod-${DATE}-${GITHUB_RUN_ID}"
          TAG="${{ inputs.release_tag }}"
          if [ -z "$TAG" ]; then TAG="$AUTO_TAG"; fi
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "name=Batocera Mod $TAG" >> "$GITHUB_OUTPUT"

      - name: Upload to Release (single)
        if: steps.sizecheck.outputs.need_split == 'false'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.tag.outputs.tag }}
          name: ${{ steps.tag.outputs.name }}
          prerelease: ${{ inputs.prerelease }}
          generate_release_notes: true
          files: |
            image.img
            image.img.sha256
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload to Release (split parts)
        if: steps.sizecheck.outputs.need_split == 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.tag.outputs.tag }}
          name: ${{ steps.tag.outputs.name }}
          prerelease: ${{ inputs.prerelease }}
          generate_release_notes: true
          files: |
            image.img.part.*
            image.img.parts.sha256
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # ===== 从 Release 下载资产，合并为单一镜像 reldl/image.img =====
      - name: Download assets back from Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euxo pipefail
          mkdir -p reldl
          gh release download "${{ steps.tag.outputs.tag }}" --dir reldl --pattern "image.img" || true
          gh release download "${{ steps.tag.outputs.tag }}" --dir reldl --pattern "image.img.part.*" || true
          if ls reldl/image.img.part.* 1>/dev/null 2>&1; then
            echo "Reassembling split parts..."
            cat reldl/image.img.part.* > reldl/image.img
          fi
          # 确保最终文件存在
          test -f reldl/image.img
          ls -lh reldl

      # ===== 安装 BaiduPCS-Go（兼容不同版本包名/目录结构）=====
      - name: Install BaiduPCS-Go
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euxo pipefail
          mkdir -p bpcs
          # 下载 linux-amd64 包（zip 或 tar.gz 均可）
          gh release download -R qjfoidnh/BaiduPCS-Go -p '*linux-amd64*.zip' -D bpcs || true
          gh release download -R qjfoidnh/BaiduPCS-Go -p '*linux-amd64*.tar.gz' -D bpcs || true
          # 解压
          if ls bpcs/*.zip 1>/dev/null 2>&1; then
            unzip -q bpcs/*.zip -d bpcs
          fi
          if ls bpcs/*.tar.gz 1>/dev/null 2>&1; then
            tar -xzf bpcs/*.tar.gz -C bpcs
          fi
          # 找到可执行文件并做固定链接
          BIN="$(find bpcs -type f -name 'BaiduPCS-Go' | head -n 1 || true)"
          if [ -z "$BIN" ]; then
            echo "❌ 未找到 BaiduPCS-Go 可执行文件"; ls -R bpcs; exit 1
          fi
          chmod +x "$BIN"
          ln -sf "$BIN" bpcs/BaiduPCS-Go
          bpcs/BaiduPCS-Go version || true

      # ===== 用完整 BAIDU_COOKIE 登录并上传到百度网盘 =====
      - name: Login BaiduPCS-Go (with cookie)
        env:
          BAIDU_COOKIE: ${{ secrets.BAIDU_COOKIE }}
        run: |
          set -euxo pipefail
          if [ -z "${BAIDU_COOKIE:-}" ]; then
            echo "❌ 缺少百度网盘 Cookie：请在仓库 Secrets 配置 BAIDU_COOKIE"; exit 1;
          fi
          bpcs/BaiduPCS-Go login -cookie="${BAIDU_COOKIE}"
          bpcs/BaiduPCS-Go who

      - name: Upload image to Baidu Netdisk
        env:
          BAIDU_PATH: ${{ inputs.baidu_path }}
        run: |
          set -euxo pipefail
          REMOTE="${BAIDU_PATH:-/knulli_mod/}"
          bpcs/BaiduPCS-Go mkdir "$REMOTE" || true
          bpcs/BaiduPCS-Go upload reldl/image.img "$REMOTE"
          bpcs/BaiduPCS-Go ls "$REMOTE"
